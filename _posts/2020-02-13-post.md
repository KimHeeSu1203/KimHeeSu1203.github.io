---
title: "[프로그래머스] 구명보트"
date: 2020-02-18 23:20:00 -0400
categories: heesu update
---

블로그에는 내가 조금 더 색다른 방법으로 풀었다고 느껴지거나, 잘 풀었다고 느껴지는 문제들을 위주로 포스팅 할 예정이다.

프로그래머스 탐욕법 (greedy) 문제 중 구명보트 문제를 풀어보았다.

<기존> 

visit를 이용해서 이미 배에 탄 사람과 아닌 사람을 구분했다 for문을 이용해서 가장 작은 또는 가장 큰 사람을 먼저 태우고 (배 + 1, visit에 넣어줌) 만약 그 배에 탈 수 있는 사람이 있으면 그 사람 또한 visit에 넣어준다. 

그리고 아직 배에 타지 않은 사람들을 같은 방법으로 태우고, 같이 탈 수 있는 사람을 찾고 하는 방식으로 풀었다. 그런데 이미 같이 타지 못할 사람을 계속 다시 검사하는 경우를 줄이고 싶어 아래 방법을 생각해냈다. 



<이후>

 예를 들어 [50, 50, 70, 80] 의 사람과 limit가 100인 경우라고 가정하고 sort해 두었다.
0 <- MAX 70 50 50 <- MIN 으로 현재 가리키는 상대를 나타내는 MIN과 MAX을 두었다. 
현재 최소 무게 사람과 최대 무게 사람이 같이 한 배에 탈 수 없다면, 어짜피 그 다음 무게의 사람도 최대 무게 사람과 함께 탈 수 없다는 것이 핵심이었다. 만약에 '현재 최소 무게 사람'과 '현재 최대 무게 사람'이 한 배에 못타면 MAX를 한칸 내려 그 아래 사람과 비교한다 (MAX-1, 배 +1) 만약 현재 최소 무게 사람과 현재 최대 무게 사람이 같은 배에 탈 수 있으면 제일 베스트인 상황이다 (가벼운 사람끼리 사면 베스트 아님) 그러면 배 +1 하고, 그 사람들은 제외해야 하므로 MIN +1, MAX -1 한다. 

```python
def solution(people, limit): 
  answer = 0 
  people.sort() 
  min = 0 
  max = len(people)-1
  while(min <= max):
    if(people[min] + people[max] <= limit):
      answer += 1
      min += 1 
      max -= 1 
    else:
      answer += 1 
      max -= 1 
  return answer 
```

